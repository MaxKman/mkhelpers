% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregate_exp_data.R
\name{aggregate_exp_data}
\alias{aggregate_exp_data}
\title{Title Aggregate single cell expression data in pseudobulks}
\usage{
aggregate_exp_data(
  m,
  md,
  aggr_col,
  sample_col = none,
  n_cells_min,
  n_cells_normalize = 0,
  min_n_samples_aggr,
  mode = c("mean", "sum"),
  return_matrix = TRUE,
  cell_name_col = cell_name,
  expr_format = c("wide", "long"),
  subset = "none",
  subset_col,
  verbose = TRUE
)
}
\arguments{
\item{m}{A single cell matrix with genes as rows and cells as columns}

\item{md}{Metadata dataframe (must contain aggr_col, sample_col)}

\item{aggr_col}{The metadata column determining which cells to aggregate (e.g. clusters or experimental groups)}

\item{sample_col}{The metadata column identifying the sample to which each cell belongs (e.g. the donor)}

\item{n_cells_min}{The minimum number of cells for a cluster/sample combination to be included in the analysis. E.g. if set to 20, samples will be excluded for clusters, for which they contain less than 20 cells. Set to 0 to ignore this setting.}

\item{n_cells_normalize}{The number of cells to which the pseudobulking will be standardized (only applied for mode = "sum"). E.g. if set to 10000, the counts aggregated from a cluster/sample combination will be normalized as follows: count_matrix / n_cells * n_cells_normalize.}

\item{min_n_samples_aggr}{Minimum number of samples in each aggregation group. If less than min_n_samples_aggr aggregation will not be performed.}

\item{mode}{Whether to aggregate using mean() ("mean") or sum() ("sum").}

\item{return_matrix}{If set to TRUE returns a matrix with each aggregation groups as columns and genes as rows. If set to FALSE returns a dataframe}

\item{cell_name_col}{The name of the metadata column that contains the cell identifier}

\item{expr_format}{Return gene expression information in wide or long format (default: "wide")}

\item{subset}{Provide identifiers, found in subset_col, on which to subset (e.g. a character vector of cell names or cluster identities)}

\item{subset_col}{Provide a name of metadata column here to use for subsetting the data}

\item{verbose}{Whether to print messages. Default: TRUE}
}
\value{
A matrix with aggregation groups as columns and genes as rows (return_matrix = TRUE), or a dataframe containing the same information  (return_matrix = FALSE)
}
\description{
This function aggregates single cell data according to a predefined group (see aggr_col), separately for each donor
}
\examples{
\dontrun{
library(Seurat)
library(SeuratData)
InstallData("pbmc3k")
seu_pbmc <- LoadData("pbmc3k", "pbmc3k.final")

# Simulate some donors
add_donors <- seu_pbmc@meta.data \%>\%
  rownames_to_column("cell_name") \%>\%
  group_by(seurat_clusters) \%>\%
  mutate(simulated_donors = sample(5, n(), replace = TRUE)) \%>\%
  ungroup \%>\%
  column_to_rownames("cell_name") \%>\%
  select(simulated_donors)
add_donors$cell_name <- rownames(add_donors)
seu_pbmc <- AddMetaData(seu_pbmc, add_donors)

# Basic example with mode = "mean"
aggregate_exp_data(m = seu_pbmc@assays$RNA@data, md = seu_pbmc@meta.data, aggr_col = seurat_clusters, sample_col = simulated_donors, n_cells_min = 20, min_n_samples_aggr = 3, mode = "mean")

# Basic example with mode = "count"
aggregate_exp_data(m = seu_pbmc@assays$RNA@data, md = seu_pbmc@meta.data, aggr_col = seurat_clusters, sample_col = simulated_donors, n_cells_min = 20, n_cells_normalize = 10000, min_n_samples_aggr = 3, mode = "count")

# Basic example with mode = "count", return dataframe
aggregate_exp_data(m = seu_pbmc@assays$RNA@data, md = seu_pbmc@meta.data, aggr_col = seurat_clusters, sample_col = simulated_donors, n_cells_min = 20, n_cells_normalize = 10000, min_n_samples_aggr = 3, mode = "count", return_matrix = FALSE)

# Test if min_n_samples_aggr is applied correctly
md_modified <- seu_pbmc@meta.data \%>\% filter(!(seurat_clusters == 1 & simulated_donors \%in\% 1:3))
test_results <- aggregate_exp_data(m = seu_pbmc@assays$RNA@data, md = md_modified, aggr_col = seurat_clusters, sample_col = simulated_donors, n_cells_min = 20, n_cells_normalize = 10000, min_n_samples_aggr = 3, mode = "count", return_matrix = FALSE, expr_format = "long")
test_results$seurat_clusters \%>\% unique \%>\% sort

# Test if n_cells_min is applied correctly
md_modified <- seu_pbmc@meta.data \%>\% filter(!(seurat_clusters == 1 & simulated_donors \%in\% 1:3))
md_sample <- seu_pbmc@meta.data \%>\% filter(seurat_clusters == 1 & simulated_donors \%in\% 1:3) \%>\% group_by(seurat_clusters, simulated_donors) \%>\% slice_sample(n = 19)
md_modified <- bind_rows(md_modified, md_sample)
test_results <- aggregate_exp_data(m = seu_pbmc@assays$RNA@data, md = md_modified, aggr_col = seurat_clusters, sample_col = simulated_donors, n_cells_min = 20, n_cells_normalize = 10000, min_n_samples_aggr = 3, mode = "count", return_matrix = FALSE, expr_format = "long")
test_results$seurat_clusters \%>\% unique \%>\% sort
test_results <- aggregate_exp_data(m = seu_pbmc@assays$RNA@data, md = md_modified, aggr_col = seurat_clusters, sample_col = simulated_donors, n_cells_min = 18, n_cells_normalize = 10000, min_n_samples_aggr = 3, mode = "count", return_matrix = FALSE, expr_format = "long")
test_results$seurat_clusters \%>\% unique \%>\% sort
 }
}
